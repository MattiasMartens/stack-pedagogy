<html>
    <head>
        <script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js"></script>
        <script src="https://cdn.rawgit.com/showdownjs/showdown/1.8.6/dist/showdown.min.js"></script>
    </head>
    <body>
        <div id="app"></div>
        <script>
            var vue = new Vue({
                el: "#app",
                template: `
                    <div id="app" class="row">
                        <div v-for="layer in layers" class="column" :ref="layer" :id="layer" v-html="html[layer]">
                        </div>
                    </div>
                `,
                data() {
                    const layers = ["digested", "original"];

                    const data = {
                        concepts: new Set(),
                        layers
                    };

                    layers.forEach(layer => data[layer] = null);

                    return data;
                },
                computed: {
                    html() {
                        if (this.layers.find(layer => !this[layer])) {
                            return {};
                        } else {
                            Vue.nextTick()
                                .then(this.handleHtmlLoaded);

                            return this.layers.reduce((acc, layer) => {
                                acc[layer] = this.markdownToHtml(layer);
                                return acc;
                            }, {});
                        }
                    },
                    converter() {
                        const converter = new showdown.Converter({
                            noHeaderId: true
                        });

                        const correlateExtension = {
                            type: 'output',
                            filter: (text, _, options) => {
                                const versionName = options.versionName;
                                const myRegexp = /(<h[1-7]>|<p>% )([^<]+)/g;
                                return text.split('\n').map(line => {
                                    let match = myRegexp.exec(line);
                                    if (match) {
                                        const innerText = match[2];
                                        const dataAttribute = innerText.trim().toLowerCase().replace(/[^a-zA-Z0-9]/g, "").replace(" ", "-");
                                        this.concepts.add(dataAttribute);
                                        const id = `${versionName}-${dataAttribute}`;
                                        const matchType = match[1].includes("%") ? "p" : "h*";
                                        // TODO support a syntax to override the "concept" attribute for a heading (could be e.g. "## text %% concept")
                                        // TODO wrap concepts in an enclosing tag for better styling
                                        if (matchType === "h*") {
                                            return `
                                                ${match[1].slice(0, match[1].length - 1)} class="concept-break" data-concept="${dataAttribute}" id="${id}">
                                                    ${match[2]}
                                                </${match[1].slice(1)}
                                            `;
                                        } else  {
                                            return `
                                                <span class="concept-break concept-break-invisible" data-concept="${dataAttribute}" id="${id}"></span>
                                            `;
                                        }
                                    } else {
                                        return line;
                                    }
                                }).join("\n");
                            }
                        };

                        showdown.extension('correlate', correlateExtension);
                        converter.addExtension('correlate');
                        return converter;
                    }
                },
                methods: {
                    markdownToHtml(versionName) {
                        const markdown = this[versionName];
                        this.converter.setOption('versionName', versionName);
                        return this.converter.makeHtml(markdown);
                    },
                    randomColor() {
                        return `rgb(${(new Array(3)).fill(0).map(() => Math.floor(Math.random() * 255)).join(",")})`;
                    },
                    handleHtmlLoaded() {
                        // POC: connect concept breaks between versions using SVG lines
                        const domElementsByConcept = Array.from(this.concepts).reduce((acc, concept) => {
                            const domElementsByLayer = this.layers.reduce((acc, layer) => {
                                const element = this.$refs[layer][0].querySelector(`[data-concept='${concept}'`);
                                if (Array.from(element.classList).includes("concept-break-invisible")) {
                                    acc[layer] = element.nextElementSibling;
                                } else {
                                    acc[layer] = element;
                                }

                                acc[layer].style.outline = `solid 1px ${this.randomColor()}`;

                                return acc;
                            }, {});

                            acc[concept] = domElementsByLayer;
                            return acc;
                        }, {});
                    }
                },
                mounted() {
                    const fetchVersion = str => {
                        const myRequest = new Request(str + '.md');
                        fetch(myRequest).then((response) => response
                            .text()
                            .then(text => {
                                this[str] = text;
                            }))
                    }

                    fetchVersion('original');
                    fetchVersion('digested');
                }
            });
        </script>
        <style>
            code {
                display: none;
            }

            .column {
                width: 50%;
                float: left;
            }

            .column :-webkit-any(h1,h2,h3,h4,h5,h6,h7,p) {
                max-width: 100%;
                width: fit-content;
            }
        </style>
    </body>
</html>